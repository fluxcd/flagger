# Gloo Mesh Canary Deployments

This guide shows you how to use the [Gloo Mesh](https://gloo.solo.io/) gateway
and Flagger to automate canary releases.

![Flagger Gloo Mesh Gateway](https://raw.githubusercontent.com/fluxcd/flagger/main/docs/diagrams/flagger-gloo-overview.png)

## Prerequisites

Gloo Mesh requires a Kubernetes cluster **v1.21** or newer.

This guide was written for Flagger version **1.21.0** or higher. 

Before continuing with this tutorial, you need to have a cluster with Gloo Mesh installed on it.
A simple step-by-step guide is shown in Solo's official documentation ["Quick start Gloo Mesh on Kubernetes"](https://docs.solo.io/gloo-mesh-enterprise/latest/getting_started/managed_kubernetes/).

Install Flagger on the data plane cluster where workloads run:

```bash
helm repo add flagger https://flagger.app
kubectl apply -f https://raw.githubusercontent.com/fluxcd/flagger/main/artifacts/flagger/crd.yaml

helm upgrade -i flagger flagger/flagger \
--namespace=gloo-mesh \
--set crd.create=false \
--set meshProvider=gloo-mesh \
--set metricsServer=http://prometheus-server
```
> **NOTE:** In Gloo Mesh the Prometheus server runs on the Management plane. It's up to the reader to expose Prometheus and make it available to the data plane clusters.

## Bootstrap

Workloads on Gloo Mesh must be deployed on a Workspace. A workspace groups a set of namespaces that can span across clusters. 
For more information follow the ["Gloo Mesh docs on Multi-tenancy"](https://docs.solo.io/gloo-mesh-enterprise/main/concepts/multi-tenancy/).

Create the workspace below on the management plane:

```bash
apiVersion: admin.gloo.solo.io/v2
kind: Workspace
metadata:
  labels:
    allow_ingress: "true"
  name: podinfo
  namespace: gloo-mesh
spec:
  workloadClusters:
  - name: cluster1
    namespaces:
    - name: test
```

Save the above resource as `podinfo-workspace.yaml` and then apply it:

```bash
kubectl apply -f podinfo-workspace.yaml
```
Next, create the test namespace in the data plane cluster.
```bash
kubectl create ns test
```

Configure the workspace to expose services to the Gateways workspace. 
The Gateways workspace was created during the Gloo Mesh Quick start guide.
```bash
apiVersion: admin.gloo.solo.io/v2
kind: WorkspaceSettings
metadata:
  name: podinfo
  namespace: test
spec:
  importFrom:
  - workspaces:
    - name: gateways
    resources:
    - kind: SERVICE
  exportTo:
  - workspaces:
    - name: gateways
    resources:
    - kind: SERVICE
      labels:
        expose: "true"
    - kind: ALL
      labels:
        expose: "true"
```

Save the above resource as `podinfo-workspacesettings.yaml` and then apply it:

```bash
kubectl apply -f podinfo-workspacesettings.yaml
```

Label the namespace for automatic sidecar injection. Update the label to match your installed Istio revision:

```bash
kubectl label namespace test istio.io/rev=1-13
```

Create a deployment:
```bash
kubectl -n test apply -f https://raw.githubusercontent.com/fluxcd/flagger/main/kustomize/podinfo/deployment.yaml
```

Deploy the load testing service to generate traffic during the canary analysis:
```bash
kubectl -n test apply -k https://github.com/fluxcd/flagger//kustomize/tester?ref=main
```

Create a Route Table that delegates the routing decision to a Route Table that will be generated by Flagger:

```yaml
apiVersion: networking.gloo.solo.io/v2
kind: RouteTable
metadata:
  name: podinfo
  namespace: test
  labels:
    expose: "true"
spec:
  hosts:
    - 'podinfo.test.svc.cluster.local'
  virtualGateways:
    - name: north-south-gw
      namespace: istio-gateways
      cluster: cluster1
  http:
    - delegate:
        routeTables:
          - name: podinfo-delegate
            namespace: test
```

Save the above resource as `podinfo-routetable.yaml` and then apply it:

```bash
kubectl apply -f ./podinfo-routetable.yaml
```

Create a canary custom resource that refers to the Route Table we just created:

```yaml
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: podinfo
  namespace: test
  labels:
    app: podinfo
spec:
  provider: gloo-mesh
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: podinfo
  routeTableRef:
    name: podinfo
    namespace: test
  service:
    port: 9898
    targetPort: 9898
    apex:
      labels:
        expose: "true"
    canary:
      labels:
        expose: "true"
    primary:
      labels:
        expose: "true"
  progressDeadlineSeconds: 60
  analysis:
    interval: 20s
    threshold: 5
    maxWeight: 50
    stepWeight: 30
    metrics:
    - name: request-success-rate
      thresholdRange:
        min: 99
      interval: 1m
    - name: request-duration
      thresholdRange:
        max: 500
      interval: 30s
    webhooks:
      - name: acceptance-test
        type: pre-rollout
        url: http://flagger-loadtester.test/
        timeout: 30s
        metadata:
          type: bash
          cmd: "curl -sd 'test' http://podinfo-canary.test:9898/token | grep token"
      - name: load-test
        type: rollout
        url: http://flagger-loadtester.test/
        metadata:
          cmd: "hey -z 2m -q 10 -c 2 http://podinfo-canary.test:9898/"
```

Save the above resource as `podinfo-canary.yaml` and then apply it:

```bash
kubectl apply -f ./podinfo-canary.yaml
```

After a couple of seconds Flagger will create the following objects:

```bash
deployment.apps/podinfo-primary
service/podinfo
service/podinfo-canary
service/podinfo-primary

# the delegate route table that shifts the traffic to the canary
routetable.networking.gloo.solo.io/podinfo-delegate
```

When the bootstrap finishes Flagger will set the canary status to initialized:

```bash
kubectl -n test get canary podinfo

NAME      STATUS        WEIGHT   LASTTRANSITIONTIME
podinfo   Initialized   0        2019-05-17T08:09:51Z
```

## Automated canary promotion

Flagger implements a control loop that gradually shifts traffic to the canary while measuring
key performance indicators like HTTP requests success rate, requests average duration, and pod health.
Based on the analysis of the KPIs a canary is promoted or aborted, and the analysis result is published to Slack.

![Flagger Canary Stages](https://raw.githubusercontent.com/fluxcd/flagger/main/docs/diagrams/flagger-canary-steps.png)

Trigger a canary deployment by updating the container image:

```bash
kubectl -n test set image deployment/podinfo \
podinfod=ghcr.io/stefanprodan/podinfo:6.0.1
```

Flagger detects that the deployment revision changed and starts a new rollout:

```text
kubectl -n test describe canary/podinfo

Status:
  Canary Weight:         0
  Failed Checks:         0
  Phase:                 Succeeded
Events:
  Type     Reason  Age                  From     Message
  ----     ------  ----                 ----     -------
  Normal   Synced  2m3s                  flagger  New revision detected! Scaling up podinfo.test
  Normal   Synced  103s                  flagger  Starting canary analysis for podinfo.test
  Normal   Synced  103s                  flagger  Pre-rollout check acceptance-test passed
  Normal   Synced  103s                  flagger  Advance podinfo.test canary weight 30
  Warning  Synced  83s                   flagger  Halt advancement no values found for istio metric request-success-rate probably podinfo.test is not receiving traffic: running query failed: no values found
  Normal   Synced  63s                   flagger  Advance podinfo.test canary weight 60
  Normal   Synced  43s                   flagger  Copying podinfo.test template spec to podinfo-primary.test
  Normal   Synced  23s                   flagger  Routing all traffic to primary
  Normal   Synced  3s                    flagger  (combined from similar events): Promotion completed! Scaling down podinfo.test

```

> **NOTE:** If you apply new changes to the deployment during the canary analysis, Flagger will restart the analysis.

## Automated rollback

During the canary analysis you can generate HTTP 500 errors and high latency to test if
Flagger pauses and rolls back the faulted version.

Trigger another canary deployment:

```bash
kubectl -n test set image deployment/podinfo \
podinfod=ghcr.io/stefanprodan/podinfo:6.0.2
```

Generate HTTP 500 errors:

```bash
watch -n .2 'curl -s <gateway-ip>/status/500 -H "Host: podinfo.test.svc.cluster.local"' 
```

When the number of failed checks reaches the canary analysis threshold, the traffic is routed back to the primary,
the canary is scaled to zero and the rollout is marked as failed.

```text
kubectl -n test describe canary/podinfo

Status:
  Canary Weight:         0
  Failed Checks:         10
  Phase:                 Failed
Events:
  Type     Reason  Age   From     Message
  ----     ------  ----  ----     -------
  Normal   Synced  4m50s                  flagger  New revision detected! Scaling up podinfo.test
  Normal   Synced  4m30s                  flagger  Starting canary analysis for podinfo.test
  Normal   Synced  4m30s                  flagger  Pre-rollout check acceptance-test passed
  Normal   Synced  4m30s                  flagger  Advance podinfo.test canary weight 30
  Warning  Synced  4m10s                  flagger  Halt advancement no values found for istio metric request-success-rate probably podinfo.test is not receiving traffic: running query failed: no values found
  Warning  Synced  3m50s                  flagger  Halt podinfo.test advancement success rate 89.02% < 99%
  Warning  Synced  3m30s                  flagger  Halt podinfo.test advancement success rate 90.34% < 99%
  Warning  Synced  3m10s                  flagger  Halt podinfo.test advancement success rate 93.43% < 99%
  Warning  Synced  2m50s                  flagger  Halt podinfo.test advancement success rate 93.95% < 99%
  Warning  Synced  2m30s                  flagger  Rolling back podinfo.test failed checks threshold reached 5
  Warning  Synced  2m30s                  flagger  Canary failed! Scaling down podinfo.test
```

For an in-depth look at the analysis process read the [usage docs](../usage/how-it-works.md).
