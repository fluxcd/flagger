// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/supergloo/api/external/istio/networking/v1alpha3/sidecar.proto

package v1alpha3

import (
	bytes "bytes"
	fmt "fmt"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ConfigScope defines the visibility of an Istio configuration artifact in
// a namespace when the namespace is imported.  By default all
// configuration artifacts are public. Configurations with private scope
// will not be imported when the namespace containing the configuration is
// imported in a Sidecar.
type ConfigScope int32

const (
	// Config with this scope are visible to all workloads in the mesh
	ConfigScope_PUBLIC ConfigScope = 0
	// Configs with this scope are visible to only workloads in the same
	// namespace as the configuration resource.
	ConfigScope_PRIVATE ConfigScope = 1
)

var ConfigScope_name = map[int32]string{
	0: "PUBLIC",
	1: "PRIVATE",
}

var ConfigScope_value = map[string]int32{
	"PUBLIC":  0,
	"PRIVATE": 1,
}

func (x ConfigScope) String() string {
	return proto.EnumName(ConfigScope_name, int32(x))
}

func (ConfigScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{0}
}

// $hide_from_docs
// CaptureMode describes how traffic to a listener is expected to be
// captured. Applicable only when the listener is bound to an IP.
type CaptureMode int32

const (
	// The default capture mode defined by the environment
	CaptureMode_DEFAULT CaptureMode = 0
	// Capture traffic using IPtables redirection
	CaptureMode_IPTABLES CaptureMode = 1
	// No traffic capture. When used in egress listener, the application is
	// expected to explicitly communicate with the listener port/unix
	// domain socket. When used in ingress listener, care needs to be taken
	// to ensure that the listener port is not in use by other processes on
	// the host.
	CaptureMode_NONE CaptureMode = 2
)

var CaptureMode_name = map[int32]string{
	0: "DEFAULT",
	1: "IPTABLES",
	2: "NONE",
}

var CaptureMode_value = map[string]int32{
	"DEFAULT":  0,
	"IPTABLES": 1,
	"NONE":     2,
}

func (x CaptureMode) String() string {
	return proto.EnumName(CaptureMode_name, int32(x))
}

func (CaptureMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{1}
}

// `Sidecar` describes the configuration of the sidecar proxy that mediates
// inbound and outbound communication to the workload it is attached to. By
// default, Istio will program all sidecar proxies in the mesh with the
// necessary configuration required to reach every workload in the mesh, as
// well as accept traffic on all the ports associated with the
// workload. The Sidecar resource provides a way to fine tune the set of
// ports, protocols that the proxy will accept when forwarding traffic to
// and from the workload. In addition, it is possible to restrict the set
// of services that the proxy can reach when forwarding outbound traffic
// from the workload.
//
// Services and configuration in a mesh are organized into one or more
// namespaces (e.g., a Kubernetes namespace or a CF org/space). A Sidecar
// resource in a namespace will apply to one or more workloads in the same
// namespace, selected using the workloadSelector. In the absence of a
// workloadSelector, it will apply to all workloads in the same
// namespace. When determining the Sidecar resource to be applied to a
// workload, preference will be given to the resource with a
// workloadSelector that selects this workload, over a Sidecar resource
// without any workloadSelector.
//
// NOTE: *_Each namespace can have only one Sidecar resource without any
// workload selector_*. The behavior of the system is undefined if more
// than one selector-less Sidecar resources exist in a given namespace. The
// behavior of the system is undefined if two or more Sidecar resources
// with a workload selector select the same workload.
//
// The example below delcares a Sidecar resource in the prod-us1 namespace
// that configures the sidecar to allow egress traffic to public services
// in the prod-us1, prod-apis, and the istio-system namespaces.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: Sidecar
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   egress:
//   - hosts:
//     - "prod-us1/*"
//     - "prod-apis/*"
//     - "istio-system/*"
// ```
//
type Sidecar struct {
	// $hide_from_docs
	// Criteria used to select the specific set of pods/VMs on which this
	// sidecar configuration should be applied. If omitted, the sidecar
	// configuration will be applied to all workloads in the current config
	// namespace.
	WorkloadSelector *WorkloadSelector `protobuf:"bytes,1,opt,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty"`
	// $hide_from_docs
	// Ingress specifies the configuration of the sidecar for processing
	// inbound traffic to the attached workload. If omitted, Istio will
	// autoconfigure the sidecar based on the information about the workload
	// obtained from the orchestration platform (e.g., exposed ports, services,
	// etc.).
	Ingress []*IstioIngressListener `protobuf:"bytes,2,rep,name=ingress,proto3" json:"ingress,omitempty"`
	// Egress specifies the configuration of the sidecar for processing
	// outbound traffic from the attached workload to other services in the
	// mesh. If omitted, Istio will autoconfigure the sidecar to be able to
	// reach every service in the mesh that is visible to this namespace.
	Egress               []*IstioEgressListener `protobuf:"bytes,3,rep,name=egress,proto3" json:"egress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Sidecar) Reset()         { *m = Sidecar{} }
func (m *Sidecar) String() string { return proto.CompactTextString(m) }
func (*Sidecar) ProtoMessage()    {}
func (*Sidecar) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{0}
}
func (m *Sidecar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Sidecar.Unmarshal(m, b)
}
func (m *Sidecar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Sidecar.Marshal(b, m, deterministic)
}
func (m *Sidecar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sidecar.Merge(m, src)
}
func (m *Sidecar) XXX_Size() int {
	return xxx_messageInfo_Sidecar.Size(m)
}
func (m *Sidecar) XXX_DiscardUnknown() {
	xxx_messageInfo_Sidecar.DiscardUnknown(m)
}

var xxx_messageInfo_Sidecar proto.InternalMessageInfo

func (m *Sidecar) GetWorkloadSelector() *WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *Sidecar) GetIngress() []*IstioIngressListener {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Sidecar) GetEgress() []*IstioEgressListener {
	if m != nil {
		return m.Egress
	}
	return nil
}

// $hide_from_docs
// IstioIngressListener specifies the properties of an inbound
// traffic listener on the sidecar proxy attached to a workload.
type IstioIngressListener struct {
	// REQUIRED. The port associated with the listener. If using
	// unix domain socket, use 0 as the port number, with a valid
	// protocol.
	Port *Port `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
	// The ip or the unix domain socket to which the listener should be bound
	// to. Format: x.x.x.x or unix:///path/to/uds or unix://@foobar (Linux
	// abstract namespace). If omitted, Istio will autoconfigure the defaults
	// based on imported services and the workload to which this
	// configuration is applied to.
	Bind string `protobuf:"bytes,2,opt,name=bind,proto3" json:"bind,omitempty"`
	// When the bind address is an IP, the captureMode option dictates
	// how traffic to the listener is expected to be captured (or not).
	CaptureMode CaptureMode `protobuf:"varint,3,opt,name=capture_mode,json=captureMode,proto3,enum=istio.networking.v1alpha3.CaptureMode" json:"capture_mode,omitempty"`
	// The loopback IP endpoint or unix domain socket to which traffic should
	// be forwarded to by default. This configuration can be used to redirect
	// traffic arriving at the bind point on the sidecar to a port or unix
	// domain socket where the application workload is listening for
	// connections. Format should be 127.0.0.1:PORT or unix:///path/to/socket
	DefaultEndpoint      string   `protobuf:"bytes,4,opt,name=default_endpoint,json=defaultEndpoint,proto3" json:"default_endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IstioIngressListener) Reset()         { *m = IstioIngressListener{} }
func (m *IstioIngressListener) String() string { return proto.CompactTextString(m) }
func (*IstioIngressListener) ProtoMessage()    {}
func (*IstioIngressListener) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{1}
}
func (m *IstioIngressListener) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IstioIngressListener.Unmarshal(m, b)
}
func (m *IstioIngressListener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IstioIngressListener.Marshal(b, m, deterministic)
}
func (m *IstioIngressListener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioIngressListener.Merge(m, src)
}
func (m *IstioIngressListener) XXX_Size() int {
	return xxx_messageInfo_IstioIngressListener.Size(m)
}
func (m *IstioIngressListener) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioIngressListener.DiscardUnknown(m)
}

var xxx_messageInfo_IstioIngressListener proto.InternalMessageInfo

func (m *IstioIngressListener) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *IstioIngressListener) GetBind() string {
	if m != nil {
		return m.Bind
	}
	return ""
}

func (m *IstioIngressListener) GetCaptureMode() CaptureMode {
	if m != nil {
		return m.CaptureMode
	}
	return CaptureMode_DEFAULT
}

func (m *IstioIngressListener) GetDefaultEndpoint() string {
	if m != nil {
		return m.DefaultEndpoint
	}
	return ""
}

// IstioEgressListener specifies the properties of an outbound traffic
// listener on the sidecar proxy attached to a workload.
type IstioEgressListener struct {
	// $hide_from_docs
	// The port associated with the listener. If using unix domain socket,
	// use 0 as the port number, with a valid protocol. The port if
	// specified, will be used as the default destination port associated
	// with the imported hosts. If the port is omitted, Istio will infer the
	// listener ports based on the imported hosts. Note that when multiple
	// egress listeners are specified, where one or more listeners have
	// specific ports while others have no port, the hosts exposed on a
	// listener port will be based on the listener with the most specific
	// port.
	Port *Port `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
	// $hide_from_docs
	// The ip or the unix domain socket to which the listener should be bound
	// to. Port MUST be specified if bind is not empty. Format:
	// x.x.x.x or unix:///path/to/uds or unix://@foobar (Linux abstract
	// namespace). If omitted, Istio will autoconfigure the defaults based on
	// imported services and the workload to which this configuration is
	// applied to.
	Bind string `protobuf:"bytes,2,opt,name=bind,proto3" json:"bind,omitempty"`
	// When the bind address is an IP, the captureMode option dictates
	// how traffic to the listener is expected to be captured (or not).
	CaptureMode CaptureMode `protobuf:"varint,3,opt,name=capture_mode,json=captureMode,proto3,enum=istio.networking.v1alpha3.CaptureMode" json:"capture_mode,omitempty"`
	// One or more services/virtualServices exposed by the listener in
	// namespace/dnsName format.  Publicly scoped services and
	// VirtualServices from remote namespaces corresponding to the specified
	// hosts will be imported. The service in a namespace can be a service in
	// the service registry (e.g., a kubernetes or cloud foundry service) or
	// a service specified via ServiceEntry configuration. In addition, any
	// publicly scoped DestinationRule associated with the imported services
	// will also be imported.
	//
	// Set the namespace to * to import a particular service from any
	// available namespace (e.g., "*/foo.example.com"). Set the dnsName field
	// to * to import all services from the specified namespace (e.g.,
	// "prod/*"). The services should be specified using FQDN format.
	//
	// NOTE: Only exported services and configuration artifacts from a
	// namespace can be imported. Private services/configuration will not be
	// imported. Refer to the scope setting associated with VirtualService,
	// DestinationRule, ServiceEntry, etc. for details.
	Hosts                []string `protobuf:"bytes,4,rep,name=hosts,proto3" json:"hosts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IstioEgressListener) Reset()         { *m = IstioEgressListener{} }
func (m *IstioEgressListener) String() string { return proto.CompactTextString(m) }
func (*IstioEgressListener) ProtoMessage()    {}
func (*IstioEgressListener) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{2}
}
func (m *IstioEgressListener) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IstioEgressListener.Unmarshal(m, b)
}
func (m *IstioEgressListener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IstioEgressListener.Marshal(b, m, deterministic)
}
func (m *IstioEgressListener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioEgressListener.Merge(m, src)
}
func (m *IstioEgressListener) XXX_Size() int {
	return xxx_messageInfo_IstioEgressListener.Size(m)
}
func (m *IstioEgressListener) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioEgressListener.DiscardUnknown(m)
}

var xxx_messageInfo_IstioEgressListener proto.InternalMessageInfo

func (m *IstioEgressListener) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *IstioEgressListener) GetBind() string {
	if m != nil {
		return m.Bind
	}
	return ""
}

func (m *IstioEgressListener) GetCaptureMode() CaptureMode {
	if m != nil {
		return m.CaptureMode
	}
	return CaptureMode_DEFAULT
}

func (m *IstioEgressListener) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

// WorkloadSelector specifies the criteria used to determine if the Gateway
// or Sidecar resource can be applied to a proxy. The matching criteria
// includes the metadata associated with a proxy, workload info such as
// labels attached to the pod/VM, or any other info that the proxy provides
// to Istio during the initial handshake. If multiple conditions are
// specified, all conditions need to match in order for the workload to be
// selected. Currently, only label based selection mechanism is supported.
type WorkloadSelector struct {
	// One or more labels that indicate a specific set of pods/VMs on which
	// this sidecar configuration should be applied. The scope of label
	// search is restricted to the configuration namespace in which the the
	// resource is present.
	Labels               map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WorkloadSelector) Reset()         { *m = WorkloadSelector{} }
func (m *WorkloadSelector) String() string { return proto.CompactTextString(m) }
func (*WorkloadSelector) ProtoMessage()    {}
func (*WorkloadSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa58707ed87dfdd3, []int{3}
}
func (m *WorkloadSelector) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkloadSelector.Unmarshal(m, b)
}
func (m *WorkloadSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkloadSelector.Marshal(b, m, deterministic)
}
func (m *WorkloadSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkloadSelector.Merge(m, src)
}
func (m *WorkloadSelector) XXX_Size() int {
	return xxx_messageInfo_WorkloadSelector.Size(m)
}
func (m *WorkloadSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkloadSelector.DiscardUnknown(m)
}

var xxx_messageInfo_WorkloadSelector proto.InternalMessageInfo

func (m *WorkloadSelector) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.networking.v1alpha3.ConfigScope", ConfigScope_name, ConfigScope_value)
	proto.RegisterEnum("istio.networking.v1alpha3.CaptureMode", CaptureMode_name, CaptureMode_value)
	proto.RegisterType((*Sidecar)(nil), "istio.networking.v1alpha3.Sidecar")
	proto.RegisterType((*IstioIngressListener)(nil), "istio.networking.v1alpha3.IstioIngressListener")
	proto.RegisterType((*IstioEgressListener)(nil), "istio.networking.v1alpha3.IstioEgressListener")
	proto.RegisterType((*WorkloadSelector)(nil), "istio.networking.v1alpha3.WorkloadSelector")
	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.WorkloadSelector.LabelsEntry")
}

func init() {
	proto.RegisterFile("github.com/solo-io/supergloo/api/external/istio/networking/v1alpha3/sidecar.proto", fileDescriptor_fa58707ed87dfdd3)
}

var fileDescriptor_fa58707ed87dfdd3 = []byte{
	// 566 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0xcd, 0x72, 0xda, 0x3c,
	0x14, 0x8d, 0x80, 0x8f, 0x04, 0x39, 0xf3, 0xd5, 0x55, 0x59, 0xb8, 0x2c, 0x5a, 0xca, 0x22, 0x43,
	0xd3, 0xa9, 0x35, 0xc0, 0xa2, 0x3f, 0x3b, 0xa0, 0x4e, 0xc7, 0x33, 0x24, 0xa1, 0x86, 0xb4, 0x9d,
	0x6e, 0x18, 0x61, 0x2b, 0x46, 0x83, 0xb1, 0x3c, 0x92, 0x0c, 0xe5, 0x65, 0xba, 0xee, 0x5b, 0xf4,
	0x29, 0xfa, 0x02, 0x7d, 0x88, 0xae, 0x3b, 0xfe, 0x61, 0x92, 0x66, 0x28, 0x4d, 0x76, 0x5d, 0xf9,
	0xde, 0xab, 0x73, 0xce, 0xbd, 0x47, 0x96, 0x04, 0xdf, 0xf9, 0x4c, 0xcd, 0xe2, 0xa9, 0xe9, 0xf2,
	0x05, 0x96, 0x3c, 0xe0, 0xcf, 0x19, 0xc7, 0x32, 0x8e, 0xa8, 0xf0, 0x03, 0xce, 0x31, 0x89, 0x18,
	0xa6, 0x9f, 0x15, 0x15, 0x21, 0x09, 0x30, 0x93, 0x8a, 0x71, 0x1c, 0x52, 0xb5, 0xe2, 0x62, 0xce,
	0x42, 0x1f, 0x2f, 0x5b, 0x24, 0x88, 0x66, 0xa4, 0x83, 0x25, 0xf3, 0xa8, 0x4b, 0x84, 0x19, 0x09,
	0xae, 0x38, 0x7a, 0x98, 0x02, 0xcd, 0x2b, 0xa0, 0xb9, 0x01, 0xd6, 0x9e, 0x6c, 0x63, 0xfb, 0x44,
	0xd1, 0x15, 0x59, 0x67, 0xec, 0x5a, 0x6b, 0xdb, 0x40, 0xc9, 0x77, 0xce, 0x54, 0x3a, 0xcf, 0xb2,
	0x85, 0x17, 0x54, 0x11, 0x8f, 0x28, 0x92, 0x53, 0xf0, 0x2d, 0x28, 0x52, 0x11, 0x15, 0xcb, 0x3b,
	0xf4, 0xd8, 0xe4, 0x39, 0xa5, 0xea, 0x73, 0x9f, 0xa7, 0x21, 0x4e, 0xa2, 0xac, 0xda, 0xf8, 0x09,
	0xe0, 0xfe, 0x28, 0x33, 0x8f, 0x3e, 0xc2, 0xfb, 0x89, 0xb5, 0x80, 0x13, 0x6f, 0x22, 0x69, 0x40,
	0x5d, 0xc5, 0x85, 0x01, 0xea, 0xa0, 0xa9, 0xb5, 0x9f, 0x99, 0x7f, 0xdc, 0x12, 0xf3, 0x43, 0xce,
	0x19, 0xe5, 0x14, 0x47, 0x5f, 0xdd, 0xa8, 0x20, 0x1b, 0xee, 0xb3, 0xd0, 0x17, 0x54, 0x4a, 0xa3,
	0x50, 0x2f, 0x36, 0xb5, 0x36, 0xde, 0xa1, 0x67, 0x27, 0x2b, 0x76, 0x06, 0x1f, 0x30, 0xa9, 0x68,
	0x48, 0x85, 0xb3, 0xe1, 0xa3, 0x13, 0x58, 0xa6, 0x99, 0x52, 0x31, 0x55, 0x32, 0xff, 0xa6, 0x64,
	0xfd, 0x2e, 0x94, 0xb3, 0x1b, 0xdf, 0x01, 0xac, 0x6e, 0xeb, 0x84, 0x3a, 0xb0, 0x14, 0x71, 0xa1,
	0x72, 0xe3, 0x8f, 0x77, 0xc8, 0x0f, 0xb9, 0x50, 0x4e, 0x0a, 0x46, 0x08, 0x96, 0xa6, 0x2c, 0xf4,
	0x8c, 0x42, 0x1d, 0x34, 0x2b, 0x4e, 0x1a, 0x23, 0x1b, 0x1e, 0xba, 0x24, 0x52, 0xb1, 0xa0, 0x93,
	0x05, 0xf7, 0xa8, 0x51, 0xac, 0x83, 0xe6, 0xff, 0xed, 0xa3, 0x1d, 0x82, 0xfd, 0x0c, 0x7e, 0xca,
	0x3d, 0xea, 0x68, 0xee, 0x55, 0x82, 0x9e, 0x42, 0xdd, 0xa3, 0x97, 0x24, 0x0e, 0xd4, 0x84, 0x86,
	0x5e, 0xc4, 0x59, 0xa8, 0x8c, 0x52, 0xda, 0xea, 0x5e, 0x5e, 0xb7, 0xf2, 0x72, 0xe3, 0x1b, 0x80,
	0x0f, 0xb6, 0xf8, 0xfe, 0x27, 0x6d, 0x55, 0xe1, 0x7f, 0x33, 0x2e, 0x95, 0x34, 0x4a, 0xf5, 0x62,
	0xb3, 0xe2, 0x64, 0x49, 0xe3, 0x0b, 0x80, 0xfa, 0xcd, 0x33, 0x85, 0xce, 0x61, 0x39, 0x20, 0x53,
	0x1a, 0x48, 0x03, 0xa4, 0xbf, 0xfd, 0xc5, 0x1d, 0x0e, 0xa4, 0x39, 0x48, 0x99, 0x56, 0xa8, 0xc4,
	0xda, 0xc9, 0x65, 0x6a, 0xaf, 0xa0, 0x76, 0xad, 0x8c, 0x74, 0x58, 0x9c, 0xd3, 0x75, 0xba, 0x3b,
	0x15, 0x27, 0x09, 0x93, 0xe1, 0x96, 0x24, 0x88, 0x69, 0x6e, 0x3e, 0x4b, 0x5e, 0x17, 0x5e, 0x82,
	0xe3, 0x23, 0xa8, 0xf5, 0x79, 0x78, 0xc9, 0xfc, 0x91, 0xcb, 0x23, 0x8a, 0x20, 0x2c, 0x0f, 0x2f,
	0x7a, 0x03, 0xbb, 0xaf, 0xef, 0x21, 0x0d, 0xee, 0x0f, 0x1d, 0xfb, 0x7d, 0x77, 0x6c, 0xe9, 0xe0,
	0xb8, 0x0d, 0xb5, 0x6b, 0xd6, 0x93, 0xb5, 0x37, 0xd6, 0x49, 0xf7, 0x62, 0x30, 0xd6, 0xf7, 0xd0,
	0x21, 0x3c, 0xb0, 0x87, 0xe3, 0x6e, 0x6f, 0x60, 0x8d, 0x74, 0x80, 0x0e, 0x60, 0xe9, 0xec, 0xfc,
	0xcc, 0xd2, 0x0b, 0xbd, 0xd3, 0xaf, 0x3f, 0x1e, 0x81, 0x4f, 0x6f, 0x77, 0xbe, 0x69, 0xd1, 0xdc,
	0xbf, 0xe5, 0xbb, 0x36, 0x2d, 0xa7, 0xb7, 0xbc, 0xf3, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xaa, 0x0b,
	0x67, 0x31, 0x25, 0x05, 0x00, 0x00,
}

func (this *Sidecar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sidecar)
	if !ok {
		that2, ok := that.(Sidecar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WorkloadSelector.Equal(that1.WorkloadSelector) {
		return false
	}
	if len(this.Ingress) != len(that1.Ingress) {
		return false
	}
	for i := range this.Ingress {
		if !this.Ingress[i].Equal(that1.Ingress[i]) {
			return false
		}
	}
	if len(this.Egress) != len(that1.Egress) {
		return false
	}
	for i := range this.Egress {
		if !this.Egress[i].Equal(that1.Egress[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *IstioIngressListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IstioIngressListener)
	if !ok {
		that2, ok := that.(IstioIngressListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	if this.Bind != that1.Bind {
		return false
	}
	if this.CaptureMode != that1.CaptureMode {
		return false
	}
	if this.DefaultEndpoint != that1.DefaultEndpoint {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *IstioEgressListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IstioEgressListener)
	if !ok {
		that2, ok := that.(IstioEgressListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	if this.Bind != that1.Bind {
		return false
	}
	if this.CaptureMode != that1.CaptureMode {
		return false
	}
	if len(this.Hosts) != len(that1.Hosts) {
		return false
	}
	for i := range this.Hosts {
		if this.Hosts[i] != that1.Hosts[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *WorkloadSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkloadSelector)
	if !ok {
		that2, ok := that.(WorkloadSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
